default_platform(:ios)

platform :ios do
  desc "Build the iOS application for App Store distribution"
  lane :build_release do
    
    keychain_path = File.expand_path("./fastlane/temp.keychain")
    keychain_password = "temp_password"

    begin
      # 1. Create a new temporary keychain
      create_keychain(
        name: keychain_path,
        password: keychain_password,
        unlock: true,
        timeout: 3600,
        add_to_search_list: true,
        default_keychain: true
      )

      # 2. Decode and import the certificate
      cert_path = File.expand_path("certificate.p12")
      File.open(cert_path, "wb") do |file|
        file.write(Base64.decode64(ENV["APPLE_CERTIFICATE_BASE64"]))
      end
      import_certificate(
        keychain_name: keychain_path,
        certificate_path: cert_path,
        certificate_password: ENV['APPLE_CERTIFICATE_PASSWORD']
      )

      # 3. Explicitly allow codesign to access the keychain (Fix for "Invalid trust settings")
      set_keychain_settings(
        path: keychain_path,
        allow_without_confirmation: true
      )

      # 4. Decode and install provisioning profile
      prov_profile_path = File.expand_path("profile.mobileprovision")
      File.open(prov_profile_path, "wb") do |file|
        file.write(Base64.decode64(ENV["PROVISIONING_PROFILE_BASE64"]))
      end
      install_provisioning_profile(path: prov_profile_path)

      # 5. Set build number
      increment_build_number
      
      # 6. Build the app, explicitly telling it which keychain to use
      gym(
        scheme: "FlowCards",
        workspace: "FlowCards.xcworkspace",
        output_directory: "./build",
        output_name: "FlowCards.ipa",
        clean: true,
        keychain_path: keychain_path,
        keychain_password: keychain_password
      )
      
      UI.success("Successfully built iOS app!")
      
    rescue => e
      UI.error("Build failed: #{e.message}")
      UI.error("Backtrace: #{e.backtrace.join("\n")}")
      raise e
    ensure
      # Clean up keychain
      delete_keychain(name: keychain_path) if File.exist?(keychain_path)
      # Clean up temporary files
      File.delete(cert_path) if File.exist?(cert_path)
      File.delete(prov_profile_path) if File.exist?(prov_profile_path)
    end
  end

  desc "Archive the iOS application and ignore export errors"
  lane :archive_only do
    # Increment the build number by one
    increment_build_number

    # Define a predictable path for the archive
    output_path = "./build"
    archive_name = "FlowCards.xcarchive"
    final_archive_path = File.join(output_path, archive_name)

    begin
      # Run gym, telling it exactly where to put the archive.
      # It will still fail at exporting, but the archive will be in a known location.
      gym(
        scheme: "FlowCards",
        workspace: "FlowCards.xcworkspace",
        clean: true,
        output_directory: output_path,
        archive_path: final_archive_path
      )
    rescue => ex
      # Intentionally ignore the export error
      UI.important("Gym failed at export, which is expected. Continuing as archive should be present.")
      # Rethrow error if it's not the one we expect, just in case
      raise ex unless ex.message.include?("Error packaging up the application")
    end
    
    # Verify the archive was created at the location we specified
    if Dir.exist?(final_archive_path)
      UI.success("Successfully archived to: #{final_archive_path}")
      # Set the path for other tools or lanes to use
      lane_context[SharedValues::XCODEBUILD_ARCHIVE] = final_archive_path
    else
      UI.user_error!("Archive was not created at the expected path: #{final_archive_path}")
    end
  end
end